#include <U8g2lib.h>
#include <SPI.h>
#include <Arduino.h>
// https://github.com/olikraus/u8g2/wiki/u8g2reference#drawstr

#include <EEPROM.h>
// memory ^

#include <Wire.h>
#include <RTClib.h>
// real time clock for AFK
RTC_DS3231 rtc;

// 10, 8, 9, 51, 52, pwr, gnd
U8G2_SSD1309_128X64_NONAME0_1_4W_HW_SPI u8g2_1(U8G2_R0, 10, 8, 9);
U8G2_SSD1309_128X64_NONAME0_1_4W_HW_SPI u8g2_2(U8G2_R0, 5, 3, 4);



//charSprite
const unsigned char kirbySpriteFull [] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFC, 0xF0, 0xF0, 0x01, 0x00, 0x00, 0x00, 0x84, 0x07, 0x00, 0x1B, 0x03, 0x00, 0x00, 0x00, 0x06, 0x03, 0x00, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x86, 0x7F, 0x00, 0x18, 0x04, 0x00, 0x00, 0x00, 0xC4, 0xC8, 0xF0, 0x11, 0x06, 0x00, 0x00, 0x00, 0x4C, 0x88, 0x10, 0x31, 0x03, 0x00, 0x00, 0x00, 0x78, 0x88, 0x10, 0xA1, 0x01, 0x00, 0x00, 0x00, 0x20, 0xE8, 0xD0, 0xE1, 0x00, 0x00, 0x00, 0x00, 0x20, 0x88, 0x90, 0x21, 0x00, 0x00, 0x00, 0x00, 0x20, 0xC8, 0x90, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x58, 0x90, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x70, 0xF0, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x03, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x90, 0x01, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x0F, 0x26, 0x00, 0x00, 0x00, 0x00, 0x20, 0x80, 0x09, 0x20, 0x00, 0x00, 0x00, 0x00, 0x20, 0x80, 0x09, 0x10, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x0F, 0x10, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x1F, 0x80, 0xFB, 0x03, 0x00, 0x00, 0x00, 0x0E, 0xF0, 0xFF, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x60, 0x80, 0x01, 0x02, 0x00, 0x00, 0x00, 0x02, 0x30, 0x00, 0x03, 0x02, 0x00, 0x00, 0x00, 0x02, 0x1C, 0x00, 0x0E, 0x03, 0x00, 0x00, 0x00, 0xFE, 0x03, 0x00, 0xF8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
const unsigned char kirbySpriteOnStar [] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x10, 0x00, 0x00, 0x00, 0xFA, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x11, 0x00, 0x00, 0xE0, 0x01, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x1C, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x03, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0xC0, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x30, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x18, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x0C, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x03, 0x00, 0x00, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x01, 0x01, 0x00, 0x01, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x80, 0x00, 0x01, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x40, 0x00, 0x01, 0x00, 0x01, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x40, 0x00, 0x01, 0x00, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x20, 0x80, 0x00, 0x00, 0x02, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x20, 0x80, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x10, 0x80, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x7F, 0x80, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x30, 0x08, 0x80, 0x00, 0x00, 0x02, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x10, 0x08, 0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xD0, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x3F, 0x04, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x18, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x06, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x02, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC3, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x07, 0xC0, 0x80, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x60, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x70, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x01, 0x00, 0x00, 0xF0, 0x0F, 0x80, 0x03, 0xC0, 0x03, 0x00, 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x18, 0x38, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x80, 0x01, 0xC0, 0x01, 0x30, 0x00, 0x00, 0x0C, 0xE0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x06, 0x70, 0x00, 0xE0, 0x00, 0x00, 0x06, 0x80, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x1C, 0x00, 0x80, 0x01, 0x80, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x07, 0x00, 0x00, 0x06, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

bool introPlayed = false;

/**
Create a map of sorts with this that can store a list of numbers that index an
inventory constant to load up an inventory for you from a 'save state'

Test displaying this, need my buttons to move through an inventory

but for now
with the square moving, can store how many coins collected, a store system to upgrade
save the level you are on, coins stored and upgrades purchased in a
upgradesBought = 112112
sort of system
['range', 'speed']
would give 4 range upgrades and 2 speed on load
coin count = 110
110 coins on load
*/

struct Vect2 {
  float x;
  float y;
};

const int potPin = A0;
int potValue = 0;
int potPos = 0;

int spriteX = 10;
int spriteY = 10;

long totalSnowmanContacts = 0;

int x = 0;
int y = 15;

float xMoveAmount = 0.25;
float xMoveAmountHolder = 0.0;
float yMoveAmount = 0.25;
float yMoveAmountHolder = 0.0;

int ymove = 1;
int xmove = 1;


// Will affect AFK - display a message - TODO
bool powerWasLostToRTC = false;



// CODE
// **********SET UP ********
void setup() {
  Wire.begin();
  rtc.begin();
  Serial.begin(9600);
  u8g2_1.begin();

  u8g2_2.begin();

  EEPROM.get(0, totalSnowmanContacts);

  if (rtc.lostPower()){
    Serial.println("LOST POWER< SETTING DATE");
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
    powerWasLostToRTC = true;
  }

}

void loop(void) {

  String timeString = "";
  String dateString = "";

  DateTime moment = rtc.now();
  //moment.year() - 1, DEC; // this works and does direct arithmatic on the value so
  // we can prob calculate AFK this way

  int yearValue = (moment.year(), DEC) + 0;

  dateString += (moment.year(), DEC);
  dateString +=  "/";
  dateString +=  (moment.month(), DEC);
  dateString += "/";
  dateString +=  (moment.day(), DEC);

  timeString += (moment.hour(), DEC);
  timeString += ":";
  timeString += (moment.minute(), DEC);
  timeString += ":";
  timeString += (moment.second(), DEC);

  Serial.println(dateString);
  Serial.println(timeString);

  u8g2_1.clearBuffer();
  u8g2_1.setFont(u8g2_font_unifont_t_symbols);
  u8g2_1.drawGlyph(x, y, 0x2603);

  xMoveAmountHolder += xMoveAmount;
  yMoveAmountHolder += yMoveAmount;

  //if (xMoveAmountHolder >= 1.00) {
   x += xmove;
   //xMoveAmountHolder = 0.0;
  //}
  //if (yMoveAmountHolder >= 1.00) {
   y += ymove;
   //yMoveAmountHolder = 0.0;
  //}

  bool contactedEdge = false;
  if (x >= 118) {
    xmove *= -1;
    totalSnowmanContacts++;
    contactedEdge = true;
  } else if (x <= -5) {
    xmove *= -1;
    totalSnowmanContacts++;
    contactedEdge = true;
  }
  if (y >= 64) {
    ymove *= -1;
    totalSnowmanContacts++;
    contactedEdge = true;
  } else if (y <= 10) {
    ymove *= -1;
    totalSnowmanContacts++;
    contactedEdge = true;
  }

  if (contactedEdge) {
    EEPROM.put(0, totalSnowmanContacts);
    contactedEdge = false;
  }

  u8g2_1.setFont(u8g2_font_6x10_tf);
  u8g2_1.drawStr(55, 8, String(totalSnowmanContacts).c_str());
  u8g2_1.sendBuffer();




  //u8g2_2.clearBuffer();

  int potSum = 0;
  for (int i = 0; i < 10; ++i) {
    potSum += analogRead(potPin);
    delay(5);
  }
  potValue = potSum / 10;
  potPos = map(potValue, 0, 1023, 0, 118);

  // pot position to move an arrow over button selections
  // u8g2_2.drawButtonUTF8(62, 20, U8G2_BTN_BW2, 0,  2,  2, "Btn" );



  u8g2_2.setFontMode(0);
  u8g2_2.setDrawColor(1);
  u8g2_2.setFont(u8g2_font_ncenB08_tr);
  u8g2_2.drawStr(55, 8, String(spriteX).c_str());

  u8g2_2.sendBuffer();

  delay(250);
}



// this is full of syntax errors im sure
//void writeTextArray(U8G2_SSD1309_128X64_NONAME0_1_4W_HW_SPI *u8g2Screen, String[] words) {
  // may need to write from reverse order
  // getting the string descent and setting Y pos of bottom row
  // to screen height - descent - PADDING (prob 1 or 2)
  // then GetAscent() and write the next row above by - that much - PADDING
  //for (int i = words.length - 1; i >= 0; --i) {
    //u8g2Screen.getAscent(words[i]);
  //}
//}




void loadSaveData() {
  loadUpgrades(110); //get upgrade data
  loadCoins();
}

void loadUpgrades(int upgradeList) {

}

void loadCoins() {

}

// Need to see if it can take an int that is moment.year()
// return a value to determine how many instances to calculate for gains..
long calculateAFKGains() {
  return 1;
}
























// Collision stuff
// Vect2 poly1[] = {{0, 0}, {50, 0}, {50, 50}, {0, 50}};
// Vect2 poly2[] = {{10, 0}, {50, 10}, {50, 60}, {10, 60}};
// bool isColliding = checkSAT(poly1, 4, poly2, 4);


float dotProduct(Vect2 v1, Vect2 v2) {
  return v1.x * v2.x + v1.y * v2.y;
}

Vect2 subtract(Vect2 v1, Vect2 v2) {
  return {v1.x - v2.x, v1.y - v2.y};
}

Vect2 getNormal(Vect2 edge) {
  return {-edge.y, edge.x};
}

void projectPolygon(Vect2 axis, Vect2* vertices, int numVertices, float &mini, float &maxi) {
  mini = dotProduct(vertices[0], axis);
  maxi = mini;

  for (int i = 1; i < numVertices; ++i) {
    float projection = dotProduct(vertices[i], axis);
    if (projection < mini) {
      projection = mini;
    }
    if (projection > maxi) {
      projection = maxi;
    }
  }
}

bool checkSATCollision(Vect2* poly1, int numVertices1, Vect2* poly2, int numVertices2) {
  for (int i = 0; i < numVertices1; ++i) {
    Vect2 v1 = poly1[i];
    Vect2 v2 = poly1[(i + 1) % numVertices1];
    Vect2 edge = subtract(v2, v1);

    Vect2 axis = getNormal(edge);

    float min1, max1, min2, max2;
    projectPolygon(axis, poly1, numVertices1, min1, max1);
    projectPolygon(axis, poly2, numVertices2, min2, max2);

    if (max1 < min2 || max2 < min1) {
      // no collision, separating axis
      return false;
    }
  }

  for (int i = 0; i < numVertices2; ++i) {
    Vect2 v1 = poly2[i];
    Vect2 v2 = poly2[(i + 1) % numVertices2];
    Vect2 edge = subtract(v2, v1);

    Vect2 axis = getNormal(edge);

    float min1, max1, min2, max2;
    projectPolygon(axis, poly1, numVertices1, min1, max1);
    projectPolygon(axis, poly2, numVertices2, min2, max2);

    if (max1 < min2 || max2 < min1) {
      // no collision, separating axis
      return false;
    }
  }
}
